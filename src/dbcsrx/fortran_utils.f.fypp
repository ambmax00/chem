#:include "megalochem.fypp"
#:set ndims = range(2,MAXDIM+1)
#:set ddims = range(1,MAXDIM+1)

MODULE FORTRAN_UTILS

   USE, INTRINSIC :: ISO_C_BINDING, ONLY: c_loc, c_ptr, c_double, c_sizeof, C_NULL_CHAR, &
	 c_float, c_f_pointer, c_int, c_long_long, &
	 c_char, c_null_ptr, c_bool, c_associated, &
	 c_float_complex, c_double_complex

   IMPLICIT NONE

#:for dparam, dtype, dsuffix, basetype, cftype in cf_dtype_float_list
#:for ndim in ndims
   PUBLIC :: fortran_reshape_${ndim}$d_${dsuffix}$
#:endfor
#:endfor

CONTAINS

#:for dparam, dtype, dsuffix, basetype, cftype in cf_dtype_float_list
#:for ndim in ndims
   SUBROUTINE fortran_reshape_${ndim}$d_${dsuffix}$(c_block_2d, c_sizes_2d, &
      c_block_nd, c_sizes_nd, c_map1, c_map1_size, c_map2, c_map2_size) &
      BIND(C,name="fortran_reshape_${ndim}$d_${dsuffix}$")
    
      INTEGER(kind=c_int), DIMENSION(2), INTENT(IN) :: c_sizes_2d
      INTEGER(kind=c_int), DIMENSION(${ndim}$), INTENT(IN) :: c_sizes_nd
      ${basetype}$ (kind=${cftype}$), DIMENSION(c_sizes_2d(1),c_sizes_2d(2)), &
          INTENT(INOUT), TARGET :: c_block_2d
      ${basetype}$ (kind=${cftype}$), DIMENSION(${arrlist("c_sizes_nd", nmax=ndim)}$), &
          INTENT(INOUT) :: c_block_nd
      INTEGER(kind=c_int), INTENT(IN), VALUE :: c_map1_size, c_map2_size
      INTEGER(kind=c_int), DIMENSION(c_map1_size), INTENT(IN) :: c_map1
      INTEGER(kind=c_int), DIMENSION(c_map2_size), INTENT(IN) :: c_map2
      
      ${basetype}$ (kind=${cftype}$), DIMENSION(${shape_colon(ndim)}$), POINTER  :: block_ptr
      ${basetype}$ (kind=${cftype}$), DIMENSION(${shape_colon(2)}$), &
          POINTER, CONTIGUOUS :: block_2d_ptr
      
      INTEGER, DIMENSION(c_map1_size) :: map1
      INTEGER, DIMENSION(c_map2_size) :: map2
      INTEGER :: i
      
      NULLIFY(block_2d_ptr)
      
      map1 = c_map1 + 1
      map2 = c_map2 + 1
      block_2d_ptr => c_block_2d
      
      IF (ALL([map1, map2] == (/(i, i=1, ${ndim}$)/))) THEN
         ! to avoid costly reshape can do pointer bounds remapping as long as arrays are equivalent in memory
         block_ptr(${shape_explicit('c_block_nd', ndim)}$) => block_2d_ptr(:, :)
         c_block_nd(${shape_colon(ndim)}$) = block_ptr(${shape_colon(ndim)}$)
      ELSE
         ! need reshape due to rank reordering
         c_block_nd(${shape_colon(ndim)}$) = RESHAPE(block_2d_ptr, SHAPE=SHAPE(c_block_nd), &
	        ORDER=[map1, map2])  
      ENDIF
              
   END SUBROUTINE
#:endfor
#:endfor
   
END MODULE
