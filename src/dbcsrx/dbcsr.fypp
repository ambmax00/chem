#:mute

#:set MAXDIM = 4

#:def make_param(structname, params)
    private:
    #:for name,type,ro,rv in params
        ${ro}$<${type}$,${rv}$> c_${name}$; 
    #:endfor
    public:
    #:for name,type,ro,rv in params
        inline ${structname}$& ${name}$(${ro}$<${type}$,${rv}$> i_${name}$)
        {
            c_${name}$ = std::move(i_${name}$);
            return *this;
        }
    #:endfor
#:enddef

#:def shape_colon(n=MAXDIM)
#!    repeated colon ':' for e.g. assumed shape array notation
$:    ','.join([':']*n)
#:enddef

#:def shape_explicit(name, n=MAXDIM)
#!    explicit shape for pointer bounds remapping
$:    ", ".join(['LBOUND('+name+', '+ str(i) + '):UBOUND('+name+', '+str(i)+')' for i in range(1,n+1)])
#:enddef

#:def make_struct(structname, friend, params)
struct ${structname}$ {
    
    ${make_param(structname,params)}$
    
    ${structname}$() = default;
    friend class ${friend}$;
};
#:enddef 

#:def datasize(name, nmin, nmax)
#!    expand into list of elements "name[0].data(), name[0].size(), ...
$:    ", ".join([name + "[" + str(i) + "].data(), " + name + "[" + str(i) + "].size()" for i in range(nmin, nmax)])
#:enddef

#:def datasizeptr(name, nmin, nmax)
#!    expand into list of elements "name->at(0).data(), name->at(0).size(), ...
$:    ", ".join([name + "->at(" + str(i) + ").data(), " + name + "->at(" + str(i) + ").size()" for i in range(nmin, nmax)])
#:enddef

#:def datasize0(nmax)
#!    repeat nullptr, 0, ...
$:    ", ".join(["nullptr, 0" for i in range(0, nmax)])
#:enddef

#:def repeat(name,nmax,end='')
#! repeat name, name, ...
#:if nmax > 0
$:     ", ".join([name for i in range(0,nmax)]) + end
#:endif
#:enddef

#:def repeatvar(name,nmin,nmax,suffix,end='')
#! repeat name0, name1, ...
#:if nmax != nmin
$:    ", ".join([name + str(i) + suffix for i in range(nmin, nmax+1)]) + end
#:endif
#:enddef  

#:set typelist = ['double', 'float', 'double _Complex', 'float _Complex']
#:set typesuffix = ['d', 'f', 'c', 'z']

#! c datatypes

#:set dtype_float_prec = ['real_8', 'real_4', 'real_8', 'real_4']
#:set dtype_float_type = ['REAL(kind=real_8)', 'REAL(kind=real_4)', 'COMPLEX(kind=real_8)', 'COMPLEX(kind=real_4)']
#:set dtype_float_suffix = ['r_dp', 'r_sp', 'c_dp', 'c_sp']
#:set dtype_float_param = ['dbcsr_type_real_8', 'dbcsr_type_real_4', 'dbcsr_type_complex_8', 'dbcsr_type_complex_4']

#: set base_dtype_float_type = ['REAL', 'REAL', 'COMPLEX', 'COMPLEX']
#: set cf_dtype_float_type = ['c_double', 'c_float', 'c_double_complex', 'c_float_complex']

#: set c_dtype_float_type = ['double', 'float', 'double _Complex', 'float _Complex']

#:set cf_dtype_float_list = list(zip(dtype_float_param, dtype_float_type, dtype_float_suffix, base_dtype_float_type, cf_dtype_float_type))
#:set cf_dtype_float_list_prec = list(zip(dtype_float_prec, dtype_float_param, dtype_float_type, dtype_float_suffix, base_dtype_float_type, cf_dtype_float_type))
#:set c_dtype_float_list = list(zip(dtype_float_suffix, c_dtype_float_type))

#:def arrlist(name, nmin=1, nmax=MAXDIM, ndim_pre=0, ndim_post=0)
#!    expand array into list of elements "name(1), name(2), ..., name(n)
$:    ", ".join([name + "(" + ":," * ndim_pre + str(i) + ",:"*ndim_post + ")" for i in range(nmin, nmax+1)])
#:enddef

#:endmute
