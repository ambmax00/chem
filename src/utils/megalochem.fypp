#:mute

#:set MAXDIM = 4

#:def make_param(structname, params)
    private:
    #:for name,type,ro,rv in params
        ${ro}$<${type}$,${rv}$> c_${name}$; 
    #:endfor
    public:
    #:for name,type,ro,rv in params
        inline ${structname}$& ${name}$(${ro}$<${type}$,${rv}$> i_${name}$)
        {
            c_${name}$ = std::move(i_${name}$);
            return *this;
        }
    #:endfor
#:enddef

#:def shape_colon(n=MAXDIM)
#!    repeated colon ':' for e.g. assumed shape array notation
$:    ','.join([':']*n)
#:enddef

#:def shape_explicit(name, n=MAXDIM)
#!    explicit shape for pointer bounds remapping
$:    ", ".join(['LBOUND('+name+', '+ str(i) + '):UBOUND('+name+', '+str(i)+')' for i in range(1,n+1)])
#:enddef

#:def make_struct(structname, friend, params)
struct ${structname}$ {
    
    ${make_param(structname,params)}$
    
    ${structname}$() = default;
    friend class ${friend}$;
};
#:enddef 

#:def datasize(name, nmin, nmax)
#!    expand into list of elements "name[0].data(), name[0].size(), ...
$:    ", ".join([name + "[" + str(i) + "].data(), " + name + "[" + str(i) + "].size()" for i in range(nmin, nmax)])
#:enddef

#:def datasizeptr(name, nmin, nmax)
#!    expand into list of elements "name->at(0).data(), name->at(0).size(), ...
$:    ", ".join([name + "->at(" + str(i) + ").data(), " + name + "->at(" + str(i) + ").size()" for i in range(nmin, nmax)])
#:enddef

#:def datasize0(nmax)
#!    repeat nullptr, 0, ...
$:    ", ".join(["nullptr, 0" for i in range(0, nmax)])
#:enddef

#:def repeat(name,nmax,end='')
#! repeat name, name, ...
#:if nmax > 0
$:     ", ".join([name for i in range(0,nmax)]) + end
#:endif
#:enddef

#:def repeatvar(name,nmin,nmax,suffix,end='')
#! repeat name0, name1, ...
#:if nmax != nmin
$:    ", ".join([name + str(i) + suffix for i in range(nmin, nmax+1)]) + end
#:endif
#:enddef  

#:set typelist = ['double', 'float', 'double _Complex', 'float _Complex']
#:set typesuffix = ['d', 'f', 'c', 'z']

#! c datatypes

#:set dtype_float_prec = ['real_8', 'real_4', 'real_8', 'real_4']
#:set dtype_float_type = ['REAL(kind=real_8)', 'REAL(kind=real_4)', 'COMPLEX(kind=real_8)', 'COMPLEX(kind=real_4)']
#:set dtype_float_suffix = ['r_dp', 'r_sp', 'c_dp', 'c_sp']
#:set dtype_float_param = ['dbcsr_type_real_8', 'dbcsr_type_real_4', 'dbcsr_type_complex_8', 'dbcsr_type_complex_4']

#: set base_dtype_float_type = ['REAL', 'REAL', 'COMPLEX', 'COMPLEX']
#: set cf_dtype_float_type = ['c_double', 'c_float', 'c_double_complex', 'c_float_complex']

#: set c_dtype_float_type = ['double', 'float', 'double _Complex', 'float _Complex']

#:set cf_dtype_float_list = list(zip(dtype_float_param, dtype_float_type, dtype_float_suffix, base_dtype_float_type, cf_dtype_float_type))
#:set cf_dtype_float_list_prec = list(zip(dtype_float_prec, dtype_float_param, dtype_float_type, dtype_float_suffix, base_dtype_float_type, cf_dtype_float_type))
#:set c_dtype_float_list = list(zip(dtype_float_suffix, c_dtype_float_type))

#:def arrlist(name, nmin=1, nmax=MAXDIM, ndim_pre=0, ndim_post=0)
#!    expand array into list of elements "name(1), name(2), ..., name(n)
$:    ", ".join([name + "(" + ":," * ndim_pre + str(i) + ",:"*ndim_post + ")" for i in range(nmin, nmax+1)])
#:enddef

#:endmute

#include <memory>
#include <optional>
#include <functional>

#:mute

#:set _REQ = "required"
#:set _OPT = "optional"
#:set _VAL = "val"
#:set _REF = "ref"

#:def _TYPE_FULL(type,reqopt,refval,wrapper)
    #:if reqopt == "required" and refval == "ref"
		#:if not wrapper
		$:	type + "&"
		#:else
		$: "std::reference_wrapper<" + type + ">"
		#:endif
	#:elif reqopt == "required" and refval == "val"
		$: type
	#:elif reqopt == "optional" and refval == "ref"
		$: "std::optional<std::reference_wrapper<" + type + ">>"
	#:elif reqopt == "optional" and refval == "val"
		$: "std::optional<" + type + ">"
	#:else
		#:stop 'Unknown value in _TYPE_FULL'
	#:endif
#:enddef

#:def _TYPE_BUILDER(type,refval)
    #:if refval == "ref"
	$:	"std::optional<std::reference_wrapper<" + type + ">>"
	#:elif refval == "val"
	$:	"std::optional<" + type + ">"
	#:else
		#:stop 'Unknown value in _TYPE_BUILDER'
	#:endif
#:enddef

#:def _TYPE_SIMPLE(type,refval)
	#:if refval == "ref"
	$: type + "&"
	#:else
	$: type
	#:endif
#:enddef

#:def _MAKE_CLASS_MEMBERS(params)
private:
	#:for name,type,reqopt,refval in params
	${_TYPE_FULL(type,reqopt,refval,False)}$ m_${name}$;
	#:endfor
#:enddef

#:def _MAKE_INIT_FROM_STRUCT(params)
$: ", ".join(["m_" + name + "(p.p_" + name + ")" &
	for name,type,reqopt,refval in params])
#:enddef

#:def _MAKE_PARAM_STRUCT(structname, params)
private:
	struct ${structname}$_pack {
	#:for name,type,reqopt,refval in params
		${_TYPE_FULL(type,reqopt,refval,False)}$ p_${name}$;
	#:endfor
	};
#:enddef

#:def _MAKE_BUILDER_CLASS(classname, structname, params, pointer)
private:
	
	class ${structname}$_base {
	private:
	#:for name,type,reqopt,refval in params
		${_TYPE_BUILDER(type,refval)}$ c_${name}$;
	#:endfor 
	
	public:
	#:for name,type,reqopt,refval in params
		inline ${structname}$_base& 
		${name}$(${_TYPE_SIMPLE(type,refval)}$ i_${name}$) {
			c_${name}$.emplace(i_${name}$);
			return *this;
		}
	#:endfor
		
		${structname}$_base() = default;
		~${structname}$_base() {}
 
	#:if pointer == True
		std::shared_ptr<${classname}$>
	#:else
		${classname}$
	#:endif
		build() {
	
			#:for name,type,reqopt,refval in params
			#:if reqopt == "required"
			if (!c_${name}$) {
				throw std::runtime_error(
				"${classname}$ builder \"${structname}$\" requires ${name}$!");
			}
			#:endif
			#:endfor
			
			${structname}$_pack p = {
			#:for ii in range(0,len(params))
			#:set delim = ','
			#:if ii == len(params) - 1
				#:set delim = ''
			#:endif
			#:set name,type,reqopt,reval = params[ii]
			#:if reqopt == "required"
				*c_${name}$${delim}$
			#:else
				(c_${name}$) ? c_${name}$ : std::nullopt${delim}$
			#:endif
			#:endfor
			};
		
			#:if pointer == True
			auto out = new ${classname}$(std::move(p));
			return std::shared_ptr<${classname}$>(out);
			#:else
			auto out = ${classname}$(std::move(p));
			return out;
			#:endif
		}
		
	};
	
public:

	static ${structname}$_base ${structname}$() { return ${structname}$_base(); }

	

#:enddef
#:endmute

